// Generated by CoffeeScript 2.4.1

/*
Redis Tagging
To create a new instance use:

	RedisTagging = require("redis-tagging")
	rt = new RedisTagging()

Parameters via an `options` object:

* `port`: *optional* Default: 6379. The Redis port.
* `host`, *optional* Default: "127.0.0.1". The Redis host.
* `options`, *optional* Default: {}. Additional options.
* `nsprefix`: *optional* Default: "rt". The namespace prefix for all Redis keys used by this module.
* `client`: *optional* An external RedisClient object which will be used for the connection.

 */
var RedisInst, RedisTagging, _isArray, _isNaN, _isNumber, _isString, _template;

RedisInst = require("redis");

_template = require("lodash/template");

_isNaN = require("lodash/isNaN");

_isArray = require("lodash/isArray");

_isNumber = require("lodash/isNumber");

_isString = require("lodash/isString");

RedisTagging = (function() {
  class RedisTagging {
    constructor(o = {}) {
      var host, options, port, ref, ref1;
      /*
      Get

      Get all tags for an ID

      Parameters object:

      * `bucket` (String)
      * `id` (String)

       */
      this.get = this.get.bind(this);
      /*
      Set

      Set (insert or update) an item

      Parameters object:

      * `bucket` (String)
      * `id` (String)
      *	`tags` (Array)
      *	`score` (Number) *optional* Default: 0

      Returns `true` when the item was set.

       */
      this.set = this.set.bind(this);
      /*
      Remove

      Remove / Delete an item

      Parameters object:

      * `bucket` (String)
      * `id` (String)

      Returns `true` even if that id did not exist.

       */
      this.remove = this.remove.bind(this);
      /*
      All IDs

      Get all IDs for a single bucket

      Parameters object:

      * `bucket` (String)

      Returns an array of item ids

       */
      this.allids = this.allids.bind(this);
      /*
      Tags

       Return the IDs of an either a single tag or an intersection/union of two or more tags

      Parameters object:

      * `bucket` (String)
      * `tags` (Array) One or more tags
      * `limit` (Number) *optional* Default=100 (0 will return 0 items but will return the total_items!)
      * `offset` (Number) *optional* Default=0
      * `withscores` (Number) *optional* Default=0 Set this to 1 to output the scores
      * `order` (String) *optional* Default ="desc"
      * `type` (String) *optional* "inter", "union" Default: "inter"

       */
      this.tags = this.tags.bind(this);
      /*
      TopTags

      Parameters object:

      * `bucket` (String)
      * `amount` (Number) *optional* Default=0 (0 returns all)

       */
      this.toptags = this.toptags.bind(this);
      /*
      Buckets

      Returns all buckets.
      Use with care: Uses redis.keys

       Returns an array with all buckets

      */
      this.buckets = this.buckets.bind(this);
      /*
      Remove a bucket and all its keys

      Use with care: Uses redis.keys

      Parameters object:

      * `bucket`(String)

       */
      this.removebucket = this.removebucket.bind(this);
      // Helpers

      // Return an array with Redis commands to delete an ID, all tag connections and update the counters 
      this._deleteID = this._deleteID.bind(this);
      this._handleError = this._handleError.bind(this);
      this._initErrors = this._initErrors.bind(this);
      this.redisns = (o.nsprefix || "rt") + ":";
      port = o.port || 6379;
      host = o.host || "127.0.0.1";
      options = o.options || {};
      if (((ref = o.client) != null ? (ref1 = ref.constructor) != null ? ref1.name : void 0 : void 0) === "RedisClient") {
        this.redis = o.client;
      } else {
        this.redis = RedisInst.createClient(port, host, options);
      }
      this._initErrors();
    }

    get(options, cb) {
      var ns;
      if (this._validate(options, ["bucket", "id"], cb) === false) {
        return;
      }
      ns = this.redisns + options.bucket;
      this.redis.smembers(`${ns}:ID:${options.id}`, (err, resp) => {
        var tag, tags;
        if (err) {
          this._handleError(cb, err);
          return;
        }
        tags = (function() {
          var j, len, results;
          results = [];
          for (j = 0, len = resp.length; j < len; j++) {
            tag = resp[j];
            results.push(tag);
          }
          return results;
        })();
        cb(null, tags);
      });
    }

    set(options, cb) {
      var id_index, ns;
      if (this._validate(options, ["bucket", "id", "score", "tags"], cb) === false) {
        return;
      }
      ns = this.redisns + options.bucket;
      id_index = ns + ':ID:' + options.id;
      // First delete this ID from the DB. We will recreate it from scratch
      this._deleteID(ns, options.id, (mc) => {
        var j, len, ref, tag;
        ref = options.tags;
        // mc contains the delete commands for this tag. Now we add add this item again with all new tags
        for (j = 0, len = ref.length; j < len; j++) {
          tag = ref[j];
          mc.push(['zincrby', ns + ':TAGCOUNT', 1, tag]);
          mc.push(['sadd', id_index, tag]);
          mc.push(['zadd', ns + ':TAGS:' + tag, options.score, options.id]);
        }
        if (options.tags.length) {
          mc.push(['sadd', ns + ':IDS', options.id]);
        }
        if (mc.length === 0) {
          cb(null, true);
          return;
        }
        this.redis.multi(mc).exec((err, resp) => {
          if (err) {
            this._handleError(cb, err);
            return;
          }
          cb(null, true);
        });
      });
    }

    remove(options, cb) {
      options.tags = [];
      this.set(options, cb);
    }

    allids(options, cb) {
      var ns;
      if (this._validate(options, ["bucket"], cb) === false) {
        return;
      }
      ns = this.redisns + options.bucket;
      this.redis.smembers(ns + ":IDS", (err, resp) => {
        if (err) {
          this._handleError(cb, err);
          return;
        }
        cb(null, resp);
      });
    }

    tags(options, cb) {
      var _keys, lastelement, mc, ns, prefix, resultkey, rndkey, tag, tagsresult;
      if (this._validate(options, ["bucket", "tags", "offset", "limit", "withscores", "type", "order"], cb) === false) {
        return;
      }
      ns = this.redisns + options.bucket;
      prefix = ns + ':TAGS:';
      // The last element to get
      lastelement = options.offset + options.limit - 1;
      mc = [];
      // Bail if no tags supplied
      if (options.tags.length === 0) {
        cb(null, {
          total_items: 0,
          items: [],
          limit: options.limit,
          offset: options.offset
        });
        return;
      }
      // Intersection and Union of multiple tags
      if (options.tags.length > 1) {
        rndkey = ns + (new Date().getTime()) + '_' + Math.floor(Math.random() * 9999999999);
        
        // Create the Redis keys from the supplied tags
        _keys = (function() {
          var j, len, ref, results;
          ref = options.tags;
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            tag = ref[j];
            results.push(prefix + tag);
          }
          return results;
        })();
        // Create a temporary Redis key with the result
        mc.push(['z' + options.type + 'store', rndkey, _keys.length].concat(_keys).concat(['AGGREGATE', 'MIN']));
        // If limit is 0 we don't need to return results. Just the total_rows
        if (options.limit > 0) {
          resultkey = rndkey;
        }
      
      // Single tag
      } else if (options.tags.length === 1) {
        // Just count the amount of IDs for this tag
        mc.push(['zcard', prefix + options.tags[0]]);
        if (options.limit > 0) {
          resultkey = prefix + options.tags[0];
        }
      }
      
      // Now run the Redis query
      // Get the IDs
      if (options.limit > 0) {
        tagsresult = ['z' + options.order + 'range', resultkey, options.offset, lastelement];
        if (options.withscores) {
          tagsresult = tagsresult.concat(['WITHSCORES']);
        }
        mc.push(tagsresult);
      }
      // Delete the temp key if this was an intersection or union
      if (options.tags.length > 1) {
        mc.push(['del', rndkey]);
      }
      this.redis.multi(mc).exec((err, resp) => {
        var e, i, rows;
        if (err) {
          this._handleError(cb, err);
          return;
        }
        // We don't have resp[1] is limit = 0. We just return an empty array then
        if (options.limit === 0) {
          rows = [];
        } else {
          rows = resp[1];
        }
        if (rows.length && options.withscores) {
          rows = (function() {
            var j, len, results;
            results = [];
            for (i = j = 0, len = rows.length; j < len; i = j += 2) {
              e = rows[i];
              results.push({
                id: e,
                score: rows[i + 1]
              });
            }
            return results;
          })();
        }
        cb(null, {
          total_items: resp[0],
          items: rows,
          limit: options.limit,
          offset: options.offset
        });
      });
    }

    toptags(options, cb) {
      var mc, ns, rediskey;
      if (this._validate(options, ["bucket", "amount"], cb) === false) {
        return;
      }
      ns = this.redisns + options.bucket;
      options.amount = options.amount - 1;
      rediskey = ns + ':TAGCOUNT';
      mc = [["zcard", rediskey], ["zrevrange", rediskey, 0, options.amount, "WITHSCORES"]];
      this.redis.multi(mc).exec((err, resp) => {
        var e, i, rows;
        if (err) {
          this._handleError(cb, err);
          return;
        }
        rows = (function() {
          var j, len, ref, results;
          ref = resp[1];
          results = [];
          for (i = j = 0, len = ref.length; j < len; i = j += 2) {
            e = ref[i];
            results.push({
              tag: e,
              count: Number(resp[1][i + 1])
            });
          }
          return results;
        })();
        cb(null, {
          total_items: resp[0],
          items: rows
        });
      });
    }

    buckets(cb) {
      this.redis.keys(this.redisns + "*" + ":TAGCOUNT", (err, resp) => {
        var e, o;
        if (err) {
          this._handleError(cb, err);
          return;
        }
        o = (function() {
          var j, len, results;
          results = [];
          for (j = 0, len = resp.length; j < len; j++) {
            e = resp[j];
            results.push(e.substr(this.redisns.length, e.length - this.redisns.length - ":TAGCOUNT".length));
          }
          return results;
        }).call(this);
        cb(null, o);
      });
    }

    removebucket(options, cb) {
      var mc, ns;
      if (this._validate(options, ["bucket"], cb) === false) {
        return;
      }
      ns = this.redisns + options.bucket;
      mc = [["smembers", ns + ":IDS"], ["zrange", ns + ":TAGCOUNT", 0, -1]];
      this.redis.multi(mc).exec((err, resp) => {
        var e, j, k, len, len1, ref, ref1, rkeys;
        if (err) {
          this._handleError(cb, err);
          return;
        }
        rkeys = [ns + ":IDS", ns + ":TAGCOUNT"];
        ref = resp[0];
        for (j = 0, len = ref.length; j < len; j++) {
          e = ref[j];
          rkeys.push(ns + ":ID:" + e);
        }
        ref1 = resp[1];
        for (k = 0, len1 = ref1.length; k < len1; k++) {
          e = ref1[k];
          rkeys.push(ns + ":TAGS:" + e);
        }
        this.redis.del(rkeys, function(err, resp) {
          cb(null, true);
        });
      });
    }

    _deleteID(ns, id, cb) {
      var id_index, mc;
      mc = [];
      id_index = ns + ':ID:' + id;
      this.redis.smembers(id_index, function(err, resp) {
        var j, len, tag;
        if (resp.length) {
// This ID already has tags. We will delete them first
          for (j = 0, len = resp.length; j < len; j++) {
            tag = resp[j];
            mc.push(['zincrby', ns + ':TAGCOUNT', -1, tag]);
            mc.push(['zrem', ns + ':TAGS:' + tag, id]);
          }
          // Also delete the index for this ID
          mc.push(['del', id_index]);
          // Delete the id in the IDS list
          mc.push(['srem', ns + ':IDS', id]);
          // Clean up the TAGCOUNT
          mc.push(['zremrangebyscore', ns + ':TAGCOUNT', 0, 0]);
        }
        // Return to the caller with the Multi-Command array
        cb(mc);
      });
    }

    _handleError(cb, err, data = {}) {
      var _err, ref;
      // try to create a error Object with humanized message
      if (_isString(err)) {
        _err = new Error();
        _err.name = err;
        _err.message = ((ref = this._ERRORS) != null ? typeof ref[err] === "function" ? ref[err](data) : void 0 : void 0) || "unkown";
      } else {
        _err = err;
      }
      cb(_err);
    }

    _initErrors() {
      var key, msg, ref;
      this._ERRORS = {};
      ref = this.ERRORS;
      for (key in ref) {
        msg = ref[key];
        this._ERRORS[key] = _template(msg);
      }
    }

    _validate(o, items, cb) {
      var item, j, len;
      for (j = 0, len = items.length; j < len; j++) {
        item = items[j];
        // General checks
        switch (item) {
          case "bucket":
          case "id":
          case "tags":
            if (!o[item]) {
              this._handleError(cb, "missingParameter", {
                item: item
              });
              return false;
            }
            break;
          case "score":
            o[item] = parseInt(o[item] || 0, 10);
            break;
          case "limit":
            if (!_isNumber(o[item]) || _isNaN(o[item])) {
              o[item] = 100;
            }
            o[item] = Math.abs(parseInt(o[item], 10));
            break;
          case "offset":
          case "withscores":
          case "amount":
            o[item] = Math.abs(parseInt(o[item] || 0, 10));
            break;
          case "order":
            o[item] = o[item] === "asc" ? "" : "rev";
            break;
          case "type":
            if (o[item] && o[item].toLowerCase() === "union") {
              o[item] = "union";
            } else {
              o[item] = "inter";
            }
        }
        switch (item) {
          case "bucket":
            o[item] = o[item].toString();
            if (!this._VALID[item].test(o[item])) {
              this._handleError(cb, "invalidFormat", {
                item: item
              });
              return false;
            }
            break;
          case "id":
            o[item] = o[item].toString();
            if (!o[item].length) {
              this._handleError(cb, "missingParameter", {
                item: item
              });
              return false;
            }
            break;
          case "score":
          case "limit":
          case "offset":
          case "withscores":
          case "amount":
            if (_isNaN(o[item])) {
              this._handleError(cb, "invalidFormat", {
                item: item
              });
              return false;
            }
            break;
          case "tags":
            if (!_isArray(o[item])) {
              this._handleError(cb, "invalidFormat", {
                item: item
              });
              return false;
            }
        }
      }
      return o;
    }

  };

  RedisTagging.prototype._VALID = {
    bucket: /^([a-zA-Z0-9_-]){1,80}$/
  };

  RedisTagging.prototype.ERRORS = {
    "missingParameter": "No <%= item %> supplied",
    "invalidFormat": "Invalid <%= item %> format"
  };

  return RedisTagging;

}).call(this);

module.exports = RedisTagging;
